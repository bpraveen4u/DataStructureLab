using System;
using System.Collections.Generic;
using System.Text;

namespace DataStuctureLab
{
    public class HuffmanNode : IData
    {
        public int data { get; set; }
        public char c;

        public HuffmanNode left;
        public HuffmanNode right;
    }

    class HuffmanCoding
    {
        public static void Run()
        {
            // number of characters. 
            int n = 6;
            char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
            int[] charfreq = { 5, 9, 12, 13, 16, 45 };

            Encode(charArray, charfreq, n);
        }

        private static void Encode(char[] charArray, int[] charfreq, int n)
        {
            MinHeapGeneric minHeap = new MinHeapGeneric(n);
            for (int i = 0; i < n; i++)
            {
                var node = new HuffmanNode();
                node.c = charArray[i];
                node.data = charfreq[i];

                node.left = null;
                node.right = null;

                // creating a Huffman node object 
                // and add it to the priority queue. 
                HeapNode<HuffmanNode> hn = new HeapNode<HuffmanNode>(node);

                // add functions adds 
                // the huffman node to the queue. 
                minHeap.Insert(hn);
            }

            // create a root node 
            HuffmanNode root = null;

            // Here we will extract the two minimum value 
            // from the heap each time until 
            // its size reduces to 1, extract until 
            // all the nodes are extracted. 
            while (minHeap.Size > 1)
            {
                // first min extract. 
                var x = minHeap.ExtractMin();

                // second min extarct. 
                var y = minHeap.ExtractMin();

                var node = new HuffmanNode();

                // to the sum of the frequency of the two nodes 
                // assigning values to the f node. 
                node.data = x.Data.data + y.Data.data;
                node.c = 'c';
                // first extracted node as left child. 
                node.left = x.Data;
                // second extracted node as the right child. 
                node.right = y.Data;

                // new node f which is equal 
                HeapNode<HuffmanNode> f = new HeapNode<HuffmanNode>(node);

                // marking the f node as the root node. 
                root = node;

                // add this node to the priority-queue. 
                minHeap.Insert(f);
            }

            // print the codes by traversing the tree 
            PrintCode(root, "");
        }
        // recursive function to print the 
        // huffman-code through the tree traversal. 
        // Here s is the huffman - code generated. 
        private static void PrintCode(HuffmanNode root, String s)
        {
            // base case; if the left and right are null 
            // then its a leaf node and we print 
            // the code s generated by traversing the tree. 
            if (root.left == null && root.right == null && Char.IsLetter(root.c))
            {
                // c is the character in the node 
                Console.WriteLine(root.c + ":" + s);

                return;
            }

            // if we go to left then add "0" to the code. 
            // if we go to the right add"1" to the code. 

            // recursive calls for left and 
            // right sub-tree of the generated tree. 
            PrintCode(root.left, s + "0");
            PrintCode(root.right, s + "1");
        }

    }
}
